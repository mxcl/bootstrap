#!/bin/sh
set -e

if [ "$(id -u)" -eq 0 ]; then
  echo "panic: do not run as root" >&2
  exit 1
fi

exec 3>&1
exec 1>&2

VERBOSE="${VERBOSE:-0}"

log_section() {
  if command -v gum >/dev/null 2>&1; then
    gum format "# $1"
  else
    printf '# %s\n' "$1"
  fi
}

if [ -n "${UPGRADE_ROOT_COMMANDS_FILE:-}" ]; then
  ROOT_COMMANDS_FILE="${UPGRADE_ROOT_COMMANDS_FILE}"
  ROOT_COMMANDS_FILE_IS_TEMP=0
else
  ROOT_COMMANDS_FILE="$(mktemp "${TMPDIR:-/tmp}/upgrade.commands.XXXXXX")"
  ROOT_COMMANDS_FILE_IS_TEMP=1
fi
if ! [ -f "${ROOT_COMMANDS_FILE}" ]; then
  echo "panic: failed to create root commands file" >&2
  exit 1
fi

SPIN_STATUS_FILE="${UPGRADE_SPIN_STATUS_FILE:-}"

set_step_title() {
  if [ -n "${SPIN_STATUS_FILE}" ]; then
    printf '%s\n' "$1" >"${SPIN_STATUS_FILE}"
  fi

  if [ "${VERBOSE}" = "1" ] || [ -z "${SPIN_STATUS_FILE}" ]; then
    log_section "$1"
  fi
}

emit_root() {
  sep=""
  for arg in "$@"; do
    escaped="$(printf '%s' "${arg}" | /usr/bin/sed "s/'/'\\\\''/g")"
    printf "%s'%s'" "${sep}" "${escaped}" >>"${ROOT_COMMANDS_FILE}"
    sep=" "
  done
  printf '\n' >>"${ROOT_COMMANDS_FILE}"
}

emit_queued_root_commands() {
  if [ -s "${ROOT_COMMANDS_FILE}" ]; then
    cat "${ROOT_COMMANDS_FILE}" >&3
  fi

  if [ "${ROOT_COMMANDS_FILE_IS_TEMP}" -eq 1 ]; then
    rm -f "${ROOT_COMMANDS_FILE}"
  fi
}

emit_stage_cleanup() {
  emit_root rm -rf "${UPGRADE_STAGE_DIR}"
}

run_with_spinner() {
  status_file="$(mktemp "${TMPDIR:-/tmp}/upgrade.status.XXXXXX")"
  worker_log="$(mktemp "${TMPDIR:-/tmp}/upgrade.log.XXXXXX")"
  if ! [ -f "${status_file}" ]; then
    echo "panic: failed to create status file" >&2
    exit 1
  fi
  if ! [ -f "${worker_log}" ]; then
    echo "panic: failed to create worker log file" >&2
    rm -f "${status_file}"
    exit 1
  fi

  UPGRADE_ROOT_COMMANDS_FILE="${ROOT_COMMANDS_FILE}" \
    UPGRADE_SPIN_STATUS_FILE="${status_file}" \
    UPGRADE_SPIN_WORKER=1 \
    VERBOSE="${VERBOSE}" \
    "$0" "$@" >"${worker_log}" 2>&1 &
  worker_pid="$!"

  set +e
  gum spin --title "Upgrading bootstrap" --show-output -- sh -c '
    worker_pid="$1"
    status_file="$2"
    last=""
    while kill -0 "${worker_pid}" 2>/dev/null; do
      current="$(cat "${status_file}" 2>/dev/null || true)"
      if [ -n "${current}" ] && [ "${current}" != "${last}" ]; then
        printf "%s\n" "${current}"
        last="${current}"
      fi
      sleep 0.1
    done
  ' sh "${worker_pid}" "${status_file}"
  spin_status="$?"

  if [ "${spin_status}" -ne 0 ] && kill -0 "${worker_pid}" 2>/dev/null; then
    kill "${worker_pid}" 2>/dev/null || true
  fi

  wait "${worker_pid}"
  worker_status="$?"
  set -e

  if [ "${spin_status}" -ne 0 ] && [ "${worker_status}" -eq 0 ]; then
    worker_status="${spin_status}"
  fi
  if [ "${worker_status}" -ne 0 ] && [ -s "${worker_log}" ]; then
    cat "${worker_log}" >&2
  fi

  rm -f "${status_file}"
  rm -f "${worker_log}"
  return "${worker_status}"
}

run_upgrade() {
  UPGRADE_STAGE_DIR="$(mktemp -d "${TMPDIR:-/tmp}/upgrade.XXXXXX")"
  if ! [ -d "${UPGRADE_STAGE_DIR}" ]; then
    echo "panic: failed to create staging directory" >&2
    exit 1
  fi
  set_step_title "Staging in ${UPGRADE_STAGE_DIR}"

  if [ -x "/opt/homebrew/bin/brew" ]; then
    set_step_title "Updating Homebrew"
    /opt/homebrew/bin/brew update
    /opt/homebrew/bin/brew upgrade
  fi

  set_step_title "Updating Pythons"
  /usr/local/bin/uv python upgrade

  if [ -x "$HOME/.cargo/bin/cargo" ]; then
    set_step_title "Updating Rust"
    "$HOME/.cargo/bin/rustup" update
  fi

  _SUDO=emit_root
